---
title: 【C#】Expression.compile()を気軽に使用してはいけない理由
tags:
  - ''
private: false
updated_at: ''
id: null
organization_url_name: null
slide: false
ignorePublish: false
---
# はじめに
C#で凝ったことを動的に行いたいときDelegateを使用することになると思います。

例えば以下のような感じ

```c#

```

ループの度に`expression.Compile()`しています。
これが最悪という話を書いていきます。

# 問題点
## 遅い、重いの二重苦
`Expression`は抽象度を非常に高く保ちながら動的に処理を組み立てることができます。
しかし式木を組み立てるということは一度コンピューターが理解できる形にコンパイルしてIL（中間言語）にしてあげなければなりません。

その部分は以下でこれが実行される度にコンパイルが走ります。
```c#
Func<int, int> compiledFunc = expression.Compile();
```

`dotnet build`をしたときを想像するとわかりやすいのですが、こういった静的言語のビルドは非常に時間がかかります。
厳密には全く違いますが、このビルド時の処理の一つがこの処理を通る度に行われていると聞いたらなんとなくやばさがわかるでしょう。

## 問題が顕在化しづらい
遅いと言ってもあくまでコンピューターの世界での話なので単純なユニットテストなどでは気づけません。
例えば以下のような単純なDelegateを計測すると以下のようになります。

```
[一度だけコンパイル] 実行時間: 0 ms, CPU時間: 0.4572 ms
[毎回コンパイル] 実行時間: 67 ms, CPU時間: 72.0822 ms
```

1秒かかっていないのでまず気づけません。
気付けるのは負荷テストなどで多大な回数実行したときになるでしょう。
最悪リリースまで気付けないなんてこともあるかもしれません。

## VMのコストがかかる
CPU時間が増大しているしている部分を見ればわかりますが、処理を変えずにこれを捌こうとするのならばサーバーのスペックもスケールアウトないし、スケールアウトしなければならなくなります。
単純にお金がかかります。

# 改善策

## キャッシュの実装

## staticでビルド時にコンパイルしておく

# まとめ
`Expression`を使用した処理は書いたときは「難しい処理書いたわー」と満足げになるんですが、このような落とし穴があります。

どうしても使用しなきゃいけない場面は存在するのですが、その場合も慎重に検討すべきです。